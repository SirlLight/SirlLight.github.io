<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>火辣辣的二毛</title>
  <icon>https://www.gravatar.com/avatar/4b66635547ef6228f81ccfbf9c0a9692</icon>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-07-25T19:04:10.088Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Sommer</name>
    <email>Huangyh_95@163.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>关于移动端的适配</title>
    <link href="http://yoursite.com/2018/07/25/%E5%85%B3%E4%BA%8E%E7%A7%BB%E5%8A%A8%E7%AB%AF%E7%9A%84%E9%80%82%E9%85%8D/"/>
    <id>http://yoursite.com/2018/07/25/关于移动端的适配/</id>
    <published>2018-07-25T14:12:56.000Z</published>
    <updated>2018-07-25T19:04:10.088Z</updated>
    
    <content type="html"><![CDATA[<p>pc有兼容，移动端有适配。适配，就是在不同尺寸的设备里，网页内容能合理地展示（自适应）或者保持相同效果的同比缩放展示。这半年做了两次h5活动，对适配有了些理解，就在这里归纳一下~</p><h3 id="为什么要做适配"><a href="#为什么要做适配" class="headerlink" title="为什么要做适配"></a>为什么要做适配</h3><p>拿出你们的大手机，相互对比一下，大概看得出有的大手机是真的大，有的大手机就不那么大，更何况还有pad这种异常大的移动便携设备，那么我们开发拿着一份设计稿，怎样才能用一份代码去保证我们做出来的网页在这不同品种尺寸的设备上能合理地显示呢？<br>这个问题就是我们做适配的原因。</p><h3 id="所见≠所得————关于视口-viewport"><a href="#所见≠所得————关于视口-viewport" class="headerlink" title="所见≠所得————关于视口(viewport)"></a>所见≠所得————关于视口(viewport)</h3><p>在reset.css里面会把html、body的宽高设置成100%，而100%这个值是继承自父级，那么html的父级是什么呢？</p><p>在PC浏览器中，有一个用来约束CSS布局视口的东西，又叫做初始包含块。这也就是所有宽高继承的由来。除去margin、padding，布局视口和浏览器可视窗口宽度是一致的，同时也和浏览器本身的宽度一致。但是，在移动端就不一样了，看个示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">* &#123;</span><br><span class="line">    margin: 0;</span><br><span class="line">    padding: 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">html,</span><br><span class="line">body &#123;</span><br><span class="line">    height: 100%;</span><br><span class="line">    width: 100%;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.left &#123;</span><br><span class="line">    float: left;</span><br><span class="line">    width: 20%;</span><br><span class="line">    height: 100%;</span><br><span class="line">    background: pink;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.right &#123;</span><br><span class="line">    float: right;</span><br><span class="line">    width: 80%;</span><br><span class="line">    height: 100%;</span><br><span class="line">    background: rgb(192, 255, 226);</span><br><span class="line">&#125;</span><br><span class="line">------</span><br><span class="line">&lt;div class=&quot;left&quot;&gt;&lt;/div&gt;</span><br><span class="line">&lt;div class=&quot;right&quot;&gt;&lt;/div&gt;</span><br></pre></td></tr></table></figure></p><p>一个常见的左右布局，在pc没什么好说的，很完美，但是在移动端，就有些不一样了<br><img src="https://sirlLight.github.io/img/h5/demo1.png" alt="demo1"><br>看！！明明设备宽高375x667，但是body的宽高居然是980x1739，震惊！</p><p>其实这个980x1739就是移动端的布局视口（layout viewport）了。</p><p>在移动端，默认的情况下，布局视口的宽度是要远远大于浏览器的宽度的。这两个视口不同于PC端，是相互独立存在的。为什么呢？试想一下，如果一个网页不对移动端进行适配，用户进行阅读的时候，如果默认情况下布局视口的宽度等于浏览器宽度，那是不是展示起来更加的不友好。也就是说，如果一个div的宽度为20%，那么它在布局视口宽度为980px的时候，展示给用户的像素还有196px，而如果宽度只有375px的情况下，宽度只有75px，展示的大小相差特别大。</p><p>所以，浏览器厂商为了让用户在小屏幕下网页也能够显示地很好，所以把布局视口宽度设置地很大，一般在768px ~ 1024px之间，最常见的宽度是980px。这个宽度可以通过document.documentElement.clientWidth得到。</p><p>layout viewport的宽度是大于浏览器可视区域的宽度的，所以我们还需要一个viewport来代表浏览器可视区域的大小，这个viewport叫做视觉视口（visual viewport）。visual viewport的宽度可以通过window.innerWidth来获取，即屏幕的宽度。附一张图更好理解<br><img src="https://sirlLight.github.io/img/h5/demo2.png" alt="demo2"></p><p>显然，这两个viewport对于移动端来讲十分不友好，完全忽略了手机本来的尺寸，所以苹果引进了理想视口（ideal viewport）的概念，理想视口的意思就是指使得布局视口跟视觉视口相等，于是就有了下面这行代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width,initial-scale=1&quot;&gt;</span><br></pre></td></tr></table></figure></p><p>width=device-width：这句代码可以把布局视口设置成为浏览器（屏幕）的宽度。</p><p>initial-scale=1：它的意思是初始缩放的比例是1，使用它的时候，同时也会将布局视口的尺寸设置为缩放后的尺寸。而缩放的尺寸就是基于屏幕的宽度来的，也就起到了和width=device-width同样的效果。</p><p>这行代码使得上面那个左右布局的body宽高等于屏幕的宽高。</p><p>另外，值得一提的是，我们在进行媒体查询的时候，查询的宽度值其实也是布局视口的宽度值。</p><h3 id="我的高清无码嘞————关于Retina屏和普通屏，模糊的由来"><a href="#我的高清无码嘞————关于Retina屏和普通屏，模糊的由来" class="headerlink" title="我的高清无码嘞————关于Retina屏和普通屏，模糊的由来"></a>我的高清无码嘞————关于Retina屏和普通屏，模糊的由来</h3><p>在设置了理想视口之后，我们在一部手机上显示没问题之后，往往换一部手机就出现了很大的问题，“卧槽，这个字怎么辣么大！！这个图怎么糊成这个鬼样子了！！！blablabla”，这些问题就跟设备的屏幕和css像素有关啦。</p><p>这时候就需要了解一个概念————设备像素比（dpr），这个东西是一个比值，可以通过window.devicePixelRatio来获取。</p><p>设备像素比 = 设备物理像素 / 设备独立像素 （只针对一个方向，x/y方向）</p><p>设备物理像素，顾名思义，不解释。</p><p>设备独立像素，这个东西就有点玄了，官方解释是：独立于设备的用于逻辑上衡量像素的单位。。。。懵逼吧，其实他妈的就是css像素！惊不惊喜（手动滑稽）只不过css像素是我们编程用的~~~</p><p>这样讲大概就明白了吧，举个例子醍醐灌顶一下：<br>iPhone6的dpr是2，也就是说 iPhone6的物理像素/css像素=2，即iphone6上用了2个物理像素来展示1个css像素。</p><h4 id="Retina屏幕"><a href="#Retina屏幕" class="headerlink" title="Retina屏幕"></a>Retina屏幕</h4><p>一般来讲，普通屏幕都是一个萝卜一个坑，一个物理像素显示一个css像素，单位长度内像素越多，分辨率越高，图像的效果越好。这就导致有一个错觉就是，屏幕尺寸越大，分辨率就越大，图像效果越好。但是苹果出了个高清屏（Retina），角度刁钻，它的像素密度比普通屏幕高，像素密度的意思就是每英寸所拥有的像素数量。给两个图大家感受一下：<br><img src="https://sirlLight.github.io/img/h5/demo3.png" alt="demo3"><br>关于屏幕的事，不多讲，我又不买新设备（呵呵）</p><h4 id="模糊的原因"><a href="#模糊的原因" class="headerlink" title="模糊的原因"></a>模糊的原因</h4><p>Retina屏幕的出现就会导致图像效果出现异常。<br>理论上，1个位图像素对应于1个物理像素，图片才能得到完美清晰的展示（全保真）。但是如iphone6的Retina屏幕下，她的dpr为2，即在它的屏幕上，一个css像素由2个物理像素来显示。本来是一个“口”字，结果变成了“田”字，相当于放大的4倍（x、y方向各放大两倍），有了4个像素点，这就导致在Retina屏幕下就会出现位图像素点不够，从而导致图片模糊的情况。</p><p>举个例子，看图：<br><img src="https://sirlLight.github.io/img/h5/demo5.png" alt="demo5"></p><p>如上图：对于dpr=2的Retina屏幕而言，1个位图像素对应于4个物理像素，由于单个位图像素不可以再进一步分割，所以只能就近取色，从而导致图片模糊(注意上述的几个颜色值)。</p><h4 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h4><p>很明显，由于位图像素不够分而产生模糊的情况，解决的办法十分简单，就是使用跟dpr同个倍数大小的图片。图片本身放大两倍，放在一个50%容器里。比如iphone6，一个200x300的img标签，原图就要提供400x600的大小，即两倍图片(@2x)。</p><p>那么当加载到img标签中，浏览器会自动对每1px的css像素减半，可以理解为此时还是维持着1:1的css像素:物理像素，不产生模糊。</p><h3 id="设计师说：这个线怎么那么粗！————关于border-1px"><a href="#设计师说：这个线怎么那么粗！————关于border-1px" class="headerlink" title="设计师说：这个线怎么那么粗！————关于border: 1px"></a>设计师说：这个线怎么那么粗！————关于border: 1px</h3><p>首先看图，在非Retina和Retina屏下css像素为1px的border：<br><img src="https://sirlLight.github.io/img/h5/demo6.png" alt="demo6"><br>看到了吗！！！设计师想要的1px border其实在Retina屏里占据的是2个物理像素，所以看起来就很粗，在Retina屏需要的是css像素为0.5px。。。<br>因为Retina屏和普通屏的区别，所以1px的border看起来像是2px的（在dpr=2的屏幕下）。像素眼的测试和设计师就会来逼逼叨= =</p><p>然而Retina屏的浏览器可能不认识0.5px的边框，将会把它解释成0px，没有边框。包括 iOS 7 和之前版本，OS X Mavericks 及以前版本，还有 Android 设备。</p><p>那这可咋办嘞？解决办法挺多，用图片啊，scale(0.5)，shadow啊等等~</p><p>大家比较推荐的是页面缩放scale(0.5)，对于dpr=2的设备，在meta标签里设置viewport(scale 0.5)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;meta name=&quot;viewport&quot; content=&quot;width=640,initial-scale=0.5,maximum-scale=0.5, minimum-scale=0.5,user-scalable=no&quot;&gt;</span><br></pre></td></tr></table></figure></p><p>这样，页面中的所有的border: 1px都将缩小0.5，从而达到border: 0.5px;的效果。</p><p>但是这样就会有一个问题，页面布局也会被缩放，字体大小也是……</p><p>不慌，这时候就可以考虑换一个单位了，嘻嘻</p><h3 id="我超爱的rem————flexible-js解决移动端适配问题"><a href="#我超爱的rem————flexible-js解决移动端适配问题" class="headerlink" title="我超爱的rem————flexible.js解决移动端适配问题"></a>我超爱的rem————flexible.js解决移动端适配问题</h3><p>rem是一个css单位，角色等同于px、em等~</p><p>这个单位的定义和em类似，不同的是em是相对于父元素，而rem是相对于根元素。rem定义是根元素的font-size, 以rem为单位，其数值与px的关系，需相对于根元素<html>的font-size计算，比如，设置根元素font-size=16px, 则表示1rem=16px。</html></p><p>基于rem的原理，我们要做的就是: 将页面的单位全换成rem，针对不同手机屏幕尺寸和dpr动态地改变根节点html的font-size大小，使得以rem为单位的元素在不同终端上以相对一致的视觉效果呈现。</p><p>这样一下就解决了上面的几个问题：</p><ul><li>图片模糊（根据dpr更改了容器大小）</li><li>border：1px（根据dpr更改缩放比例，字体大小也不会受到影响）</li><li>屏幕适配布局（根据dpr缩放）</li></ul><p>简直超酷~</p><p>这里就差一个js去完成这事了，而flexible.js就是干这事的，它的关键步骤就是：</p><ul><li>获取设备的dpr</li><li>动态改写<meta name="viewport">标签</li><li>给<html>元素添加data-dpr属性，并且动态改写data-dpr的值</html></li><li>给<html>元素添加font-size属性，并且动态改写font-size的值</html></li></ul><p>解释一下就是根据设备的屏幕宽度、dpr设置根元素的data-dpr和font-size, 这段JS代码要在所有资源加载之前执行，建议做内联处理。</p><h3 id="还原设计稿"><a href="#还原设计稿" class="headerlink" title="还原设计稿"></a>还原设计稿</h3><p>首先，拿到一份设计稿，一般是以iphone6（dpr=2）为基准的，然后用flexible.js，就可以愉快编码啦~</p><p>比如设计稿上量出一块宽高750×300px的div，这时候就转换成rem单位，公式就是：rem = px / 基准值。这个基准值就是该dpr下根元素的font-size，因为设计稿是dpr=2的，所以这个基准值是75，然后在css中的宽高尺寸等等就都换成除以75的rem就好啦~</p><p>以前我觉得适配元素rem为单位，正文字体及边距什么的还是用px为单位，但是现在，就我个人体验来讲，我觉得全部用rem会很好，包括字体大小！！！</p><p>最后留一个canvas的坑：做了适配之后的canvas绘出来的图案尺寸有问题，dpr越大，图案越小，需要在绘制过程中手动再次根据dpr更改图案的尺寸，具体原因还在看，waiting</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;pc有兼容，移动端有适配。适配，就是在不同尺寸的设备里，网页内容能合理地展示（自适应）或者保持相同效果的同比缩放展示。这半年做了两次h5活动，对适配有了些理解，就在这里归纳一下~&lt;/p&gt;
&lt;h3 id=&quot;为什么要做适配&quot;&gt;&lt;a href=&quot;#为什么要做适配&quot; class=&quot;
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>MVVM的双向绑定</title>
    <link href="http://yoursite.com/2018/05/31/MVVM%E7%9A%84%E5%8F%8C%E5%90%91%E7%BB%91%E5%AE%9A/"/>
    <id>http://yoursite.com/2018/05/31/MVVM的双向绑定/</id>
    <published>2018-05-30T16:19:55.000Z</published>
    <updated>2018-07-25T18:46:27.234Z</updated>
    
    <content type="html"><![CDATA[<h3 id="相关"><a href="#相关" class="headerlink" title="相关"></a>相关</h3><p>随便联想的衍生知识点~ 大概<del>不会</del>有机会填坑</p><ul><li><a href="http://www.cnblogs.com/indream/p/3602348.html" target="_blank" rel="noopener">m三连：MVC、MVP和MVVM</a></li><li><a href="https://www.kancloud.cn/zmwtp/vue2/149727" target="_blank" rel="noopener">vdom</a></li><li><a href="https://blog.csdn.net/u010582082/article/details/70196854" target="_blank" rel="noopener">documentFragment</a></li></ul><h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>说到双向绑定，就会想到MVVM模式。之前实习依次经历过MVC、MVP和MVVM模式，在MVC和MVP模式里，数据还只是单向绑定，即把Model绑定到View，当我们用js更新Model时，View就会自动更新，反之，不然。</p><p>而MVVM模式就很不一样啦，它的viewModel大体上就是MVC里的Controller和MVP里的Presenter了。只是MVVM模式里面View和ViewModel之间没有了MVP里的界面接口，变成了直接交互，数据和视图是双向绑定的关系，双向绑定不仅拥有单向绑定的效果，还拥有单向绑定的反之效果，即如果用户更新了View，Model的数据也自动被更新了。<font size="1">（总算成功引入了双向绑定了= =）</font></p><p>那么什么时候才会更新view嘞？最常见的操作就是表单输入啦~ 用户输入数据，更新了视图层，此时MVVM框架自动更新Model，那么这个数据就跟着视图的变化而变化了。</p><h3 id="举个栗子"><a href="#举个栗子" class="headerlink" title="举个栗子"></a>举个栗子</h3><p>vue.js就是一个使用了MVVM模式的js库。这里来一段粗糙简陋的代码示范一下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=&quot;vm&quot;&gt;</span><br><span class="line">    &lt;input type=&quot;text&quot; v-model=&quot;obj.msg&quot;&gt;</span><br><span class="line">    &lt;p&gt;&#123;&#123; obj.msg &#125;&#125;&lt;/p&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    new Vue(&#123;</span><br><span class="line">        el: &quot;#vm&quot;,</span><br><span class="line">        data: &#123;</span><br><span class="line">            obj: &#123;</span><br><span class="line">                msg: &quot;嘿嘿嘿&quot;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        created: function () &#123;</span><br><span class="line">            console.log(this.obj);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></p><p>效果：</p><p><img src="https://sirllight.github.io/img/vue-demo.gif" alt="vue demo"></p><p>双向数据绑定大概就是这个样子，就是视图（View）的变化能实时让数据模型（Model）发生变化，而数据的变化也能实时更新到视图层。分解一下这里面的操作就是双向数据绑定的基本实现流程啦~</p><ul><li>监听视图的变化</li><li>将视图的变化更新到数据模型</li><li>监听数据模型的变化</li><li>将数据模型的变化更新到视图</li></ul><p>视图层的变化主要交互造成的，比如用户输入、点击等等。那么我们只需要监听这些交互的事件，然后在事件回调函数中，将变化的值更新到Model中，这就实现了视图层变化更新数据模型。</p><p>数据模型变化的监听方式主要有三种：发布订阅模式（Backbone.js），脏数据检查（Angular.js），数据劫持（Vue.js）。</p><h4 id="发布订阅模式"><a href="#发布订阅模式" class="headerlink" title="发布订阅模式"></a>发布订阅模式</h4><p>发布订阅模式也叫作观察者模式，我的理解就是，唔，举个栗子，原生js中的事件监听就是这么一种模式。触发一个事件，就是发布了一个通知，这个通知的订阅者（addEventListener）去订阅这个回调函数，就可以执行相应的操作。落到数据绑定上就是，当数据发生了变动，就发布通知，订阅者收到这个发布，就去执行相应的操作。唔，大概就这样，具体的这里不讲，扔个链接，<a href="http://www.html-js.com/article/Study-of-twoway-data-binding-JavaScript-talk-about-JavaScript-every-day" target="_blank" rel="noopener">爱看不看</a>，这里还有个js观察者模式的文章，<a href="http://www.cnblogs.com/TomXu/archive/2012/03/02/2355128.html" target="_blank" rel="noopener">依然是爱看不看</a></p><h4 id="脏数据检查"><a href="#脏数据检查" class="headerlink" title="脏数据检查"></a>脏数据检查</h4><p>顾名思义，就是通过脏值检测的方式比对数据是否有变更，来决定是否更新视图，最简单的方式就是通过 setInterval() 定时轮询检测数据变动，当然Google不会这么low，angular只有在指定的事件触发时进入脏值检测，大致如下：</p><ul><li>DOM事件，譬如用户输入文本，点击按钮等。( ng-click )</li><li>XHR响应事件 ( $http )</li><li>浏览器Location变更事件 ( $location )</li><li>Timer事件( $timeout , $interval )</li><li>执行 $digest() 或 $apply()</li></ul><p>嗷，这一段是我复制粘贴的，对angular了解不深，一直<del>懒得</del>没有<del>兴趣</del>时间去了解，以后再说吧，留一个链接，<a href="https://github.com/xufei/blog/issues/10" target="_blank" rel="noopener">照旧爱看不看</a></p><h4 id="数据劫持"><a href="#数据劫持" class="headerlink" title="数据劫持"></a>数据劫持</h4><p>这一个方法就是这篇文章的重点了，入门vue.js的时候有些情怀，我更愿意接触它。嗷，现在对react也有感情了，女人，就是这么感性(#^.^#)，嘻嘻。唔，说回数据劫持。</p><p>ES5中对象的属性有了属性描述符，Object.defineProperty就是ES5新加的给对象属性设置描述符的方法。这个方法是真的了不起，它用下面的方式（数据描述符和存取描述符）去设置对象属性：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Object.defineProperty(obj, key,&#123;</span><br><span class="line">    value: &quot;&quot;,</span><br><span class="line">    writable: true,</span><br><span class="line">    enumerable: true,</span><br><span class="line">    configurable: true</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p>除此之外，它还有get，set的存取描述符给属性提供getter和setter方法。当存在getter，setter函数时，属性的赋值操作会触发setter函数的执行，获取操作会触发getter函数的执行。用术语来讲，这样的方法叫数据劫持<font size="1">（显得十分牛逼高深的样子）</font>。举个栗子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">var info = &#123;&#125;;</span><br><span class="line">Object.defineProperty(info, &quot;name&quot;, &#123;</span><br><span class="line">    set: function (value) &#123;</span><br><span class="line">        name = value;</span><br><span class="line">        console.log(&quot;set name :&quot; + value);</span><br><span class="line">    &#125;,</span><br><span class="line">    get: function () &#123;</span><br><span class="line">        return &quot;get name :&quot; + name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">info.name = &quot;啦啦啦&quot;;</span><br><span class="line">console.log(info.name);</span><br></pre></td></tr></table></figure></p><p>效果你们自己复制一下代码，跑个js脚本自己看咯。。。唔，算了，还是截个图:</p><p><img src="https://sirllight.github.io/img/definePro-demo.png" alt="Object.defineProperty demo"></p><p>关于这个方法具体情况，唔，<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty" target="_blank" rel="noopener">这是一条链接，爱看不看</a>。之所以说这个方法很了不起，就是因为vue.js双向绑定最核心的方法就是它，可以打印一下vue中初始化数据的对象和我们自己用Object.defineProperty()定义的对象：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=&quot;vm&quot;&gt;</span><br><span class="line">    &lt;input type=&quot;text&quot; v-model=&quot;obj.msg&quot;&gt;</span><br><span class="line">    &lt;p&gt;&#123;&#123; obj.msg &#125;&#125;&lt;/p&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">    new Vue(&#123;</span><br><span class="line">        el: &quot;#vm&quot;,</span><br><span class="line">        data: &#123;</span><br><span class="line">            obj: &#123;</span><br><span class="line">                msg: &quot;嘿嘿嘿&quot;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        created: function () &#123;</span><br><span class="line">            console.log(this.obj);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    console.log(&quot;====&quot;);</span><br><span class="line"></span><br><span class="line">    var info = &#123;&#125;;</span><br><span class="line">    Object.defineProperty(info, &quot;name&quot;, &#123;</span><br><span class="line">        set: function (value) &#123;</span><br><span class="line">            name = value;</span><br><span class="line">            console.log(&quot;set name :&quot; + value);</span><br><span class="line">        &#125;,</span><br><span class="line">        get: function () &#123;</span><br><span class="line">            return &quot;get name :&quot; + name;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    info.name = &quot;啦啦啦&quot;;</span><br><span class="line">    console.log(info.name);</span><br><span class="line">    console.log(info);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></p><p>效果：</p><p><img src="https://sirllight.github.io/img/data-demo.png" alt="data demo"></p><p>乍一眼，看起来就很像了，是吧。vue.js就是采用数据劫持结合发布订阅模式的方式，通过Object.defineProperty()来劫持各个属性的setter，getter，在数据变动时发布消息给订阅者，触发相应的监听回调来实现双向数据绑定的。</p><h3 id="vue-js实现双向绑定基本思路"><a href="#vue-js实现双向绑定基本思路" class="headerlink" title="vue.js实现双向绑定基本思路"></a>vue.js实现双向绑定基本思路</h3><p>实现MVVM主要包含两个方面：数据变化更新视图，视图变化更新数据。因为view更新model可以通过事件监听去实现，比如说监听输入事件，所以关键就在于如果数据变化怎么去更新视图。这个时候就用上了上面说的数据劫持，通过Object.defineProperty()对属性设置一个setter函数，当数据改变了就会来触发这个函数，就可以在这个函数里去更新model。<br>vue.js在这个地方使用了发布订阅的模式去进行更新model的操作。因为订阅者（watcher）会有很多个，所以就有一个消息订阅器Dep来专门收集管理这些订阅者，通过“订阅”数据变动，去执行相应的更新view的操作。双向绑定基本思路就这样，现在可以来简要实现一下。</p><h3 id="简要实现"><a href="#简要实现" class="headerlink" title="简要实现"></a>简要实现</h3><p>首先，用数据劫持简单实现一下我们想要的表现效果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=&quot;vm&quot;&gt;</span><br><span class="line">    &lt;input type=&quot;text&quot; id=&quot;input&quot;&gt;</span><br><span class="line">    &lt;p id=&quot;value&quot;&gt;&lt;/p&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">    var data = &#123;&#125;;</span><br><span class="line">    Object.defineProperty(data, &quot;msg&quot;, &#123;</span><br><span class="line">        set: function (value) &#123;</span><br><span class="line">            msg = value;</span><br><span class="line">            console.log(&quot;set input data :&quot; + value);</span><br><span class="line">            document.getElementById(&quot;value&quot;).innerHTML = value;</span><br><span class="line">        &#125;,</span><br><span class="line">        get: function () &#123;</span><br><span class="line">            return msg;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    document.getElementById(&quot;input&quot;).addEventListener(&quot;keyup&quot;, function (e) &#123;</span><br><span class="line">        data.msg = e.target.value;</span><br><span class="line">    &#125;);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></p><p>效果如图：</p><p><img src="https://sirllight.github.io/img/define-pro-demo.gif" alt="define-pro-demo"></p><p>虽然这是我们想要得到的效果，但是通过document.getElementById获取到相应的节点对象，然后去改变节点的值，这种做法是真的很粗暴了，一点都不优雅。如果封装成一个框架，这种做法肯定是不可行的，所以我们需要一个提高性能和效率的模块去解析dom并修改dom中相应变量。</p><h4 id="简单实现一个编译器Compile"><a href="#简单实现一个编译器Compile" class="headerlink" title="简单实现一个编译器Compile"></a>简单实现一个编译器Compile</h4><p>对着代码说话<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=&quot;vm&quot;&gt;</span><br><span class="line">    &lt;input type=&quot;text&quot; s-model=&quot;input&quot;&gt;</span><br><span class="line">    &#123;&#123; input &#125;&#125;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    function Sommer (options) &#123;</span><br><span class="line">        this.data = options.data;</span><br><span class="line">        var id = options.el;</span><br><span class="line">        var dom = new Compile(document.getElementById(id), this);</span><br><span class="line">        document.getElementById(id).appendChild(dom);</span><br><span class="line">    &#125;</span><br><span class="line">    new Sommer(&#123;</span><br><span class="line">        el: &quot;vm&quot;,</span><br><span class="line">        data: &#123;</span><br><span class="line">            input: &quot;嘿嘿嘿&quot;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">//compile.js</span><br><span class="line"></span><br><span class="line">function Compile (node, sommer) &#123;</span><br><span class="line">    return this.node2Fragment(node, sommer);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Compile.prototype = &#123;</span><br><span class="line">    //编译dom流程：</span><br><span class="line">    // 1.将挂载目标的所有子节点劫持到DocumentFragment</span><br><span class="line">    // 2.然后针对不同的节点类型进行解析数据绑定的处理</span><br><span class="line"></span><br><span class="line">    node2Fragment: function (node, sommer) &#123;</span><br><span class="line">        var _this = this,</span><br><span class="line">            child,</span><br><span class="line">            frag = document.createDocumentFragment();</span><br><span class="line"></span><br><span class="line">        while(child = node.firstChild) &#123;</span><br><span class="line">            _this.handleBind(child, sommer);</span><br><span class="line">            frag.append(child);    //append进文档片段之后，dom中的该节点会自动删除，所以child永远都是第一个子节点，直到子节点劫持完成为止</span><br><span class="line">        &#125;</span><br><span class="line">        return frag;</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    handleBind: function (node, sommer) &#123;</span><br><span class="line">        var reg = /\&#123;\&#123;(.*)\&#125;\&#125;/;   //文本插入分隔符正则匹配，vue可以通过delimiters:[&apos;$&#123;&apos;, &apos;&#125;&apos;]进行配置</span><br><span class="line"></span><br><span class="line">        //根据节点类型进行分别处理，1----元素节点，3----文本节点</span><br><span class="line">        if (node.nodeType === 1) &#123;</span><br><span class="line">            var attr = node.attributes,</span><br><span class="line">                attrLen = attr.length;</span><br><span class="line">            for (var i = 0; i &lt; attrLen; i++) &#123;</span><br><span class="line">                //解析s-model属性</span><br><span class="line">                if (attr[i].nodeName == &quot;s-model&quot;) &#123;</span><br><span class="line">                    var modelName = attr[i].nodeValue;  //获取s-model绑定的属性名</span><br><span class="line">                    node.addEventListener(&quot;input&quot;, function (e) &#123;</span><br><span class="line">                        //更改data中的相应属性，触发这个属性的set方法</span><br><span class="line">                        sommer.data[modelName] = e.target.value;</span><br><span class="line">                    &#125;);</span><br><span class="line">                    node.value = sommer.data[modelName];    //将数据赋值给节点</span><br><span class="line">                    node.removeAttribute(&quot;s-model&quot;);    //移除节点上的s-model属性</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if (node.nodeType === 3) &#123;</span><br><span class="line">            if (reg.test(node.nodeValue)) &#123;</span><br><span class="line">                var name = RegExp.$1.trim();  //匹配到的分隔符里的字符串</span><br><span class="line">                node.nodeValue = sommer.data[name];    //将数据模型中的该属性值赋值给这个节点</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>这个地方用到了文档碎片DocumentFragment，以前看过，觉得好像没地方用，没想到用处还是挺大的，很复杂的心情。。。这段代码的作用就是将挂在的目标节点下的所有子节点转换成文档碎片进行编译操作，等编译完成之后再将碎片添加到真实的dom节点中，在性能和效率上确实有明显的提高。</p><p>虽然代码注释还是很详细的，但是我在这里还是叨叨一下吧，首先，获取到真实的dom节点，然后分析节点的类型，根据不同的类型去解析绑定数据的标志，获取到绑定的变量，然后进行一些操作处理。这个地方就不截图了，效果就是实现了用s-model和双花括号绑定数据。</p><h4 id="实现简单的observe"><a href="#实现简单的observe" class="headerlink" title="实现简单的observe"></a>实现简单的observe</h4><p>实现了数据绑定节点之后，就可以用数据劫持对数据进行监听了，不多说，先看代码<font size="1">（html代码没变就不拿上来了）</font>：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">function Sommer (options) &#123;</span><br><span class="line">    this.data = options.data;</span><br><span class="line">    observe(this.data);</span><br><span class="line">    var id = options.el;</span><br><span class="line">    var dom = new Compile(document.getElementById(id), this);</span><br><span class="line">    document.getElementById(id).appendChild(dom);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//observe.js</span><br><span class="line"></span><br><span class="line">//监控Sommer中data的变化</span><br><span class="line">function observe (data) &#123;</span><br><span class="line">    Object.keys(data).forEach(function(key) &#123;</span><br><span class="line">        definePro(data, key, data[key]);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function definePro (data, key, val) &#123;</span><br><span class="line">    Object.defineProperty(data, key, &#123;</span><br><span class="line">        enumerable: true,</span><br><span class="line">        configurable: true,</span><br><span class="line">        get: function() &#123;</span><br><span class="line">            return val;</span><br><span class="line">        &#125;,</span><br><span class="line">        set: function(newVal) &#123;</span><br><span class="line">            val = newVal;</span><br><span class="line">            console.log(&apos;属性&apos; + key + &apos;已经被监听了，现在值为：&apos; + newVal);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这里使用数据劫持对Sommer中的data进行监听，当get和set方法触发后进行相应的操作，效果如图：</p><p><img src="https://sirllight.github.io/img/observe-demo.gif" alt="observe-demo"></p><p>可以看到虽然set方法触发了，但是文本节点的内容没有变化，我们接下来就要实现让绑定的文本节点同步变化，这个时候，就需要使用到发布订阅模式。</p><h4 id="发布订阅模式-1"><a href="#发布订阅模式-1" class="headerlink" title="发布订阅模式"></a>发布订阅模式</h4><p><a href="https://github.com/SirlLight/mvvm" target="_blank" rel="noopener">还是先上代码</a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><span class="line">//watch.js</span><br><span class="line"></span><br><span class="line">function Dep () &#123;</span><br><span class="line">    this.subs = [];</span><br><span class="line">&#125;</span><br><span class="line">Dep.prototype = &#123;</span><br><span class="line">    addSub: function(sub) &#123;</span><br><span class="line">        this.subs.push(sub);</span><br><span class="line">    &#125;,</span><br><span class="line">    notify: function() &#123;</span><br><span class="line">        this.subs.forEach(function(sub) &#123;</span><br><span class="line">            sub.update();</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">function Watcher (sommer, node, name, type) &#123;</span><br><span class="line">    Dep.target = this;  //将自己赋值给了全局变量dep.target</span><br><span class="line">    this.name = name;</span><br><span class="line">    this.node = node;</span><br><span class="line">    this.sommer = sommer;</span><br><span class="line">    this.type = type;</span><br><span class="line">    this.update();</span><br><span class="line">    Dep.target = null;  //因为它是全局变量，也是 watcher 与 dep 关联的唯一桥梁，任何时刻都必须保证 Dep.target 只有一个值。</span><br><span class="line">&#125;</span><br><span class="line">Watcher.prototype = &#123;</span><br><span class="line">    update: function () &#123;</span><br><span class="line">        this.get();</span><br><span class="line">        this.node[this.type] = this.value;</span><br><span class="line">    &#125;,</span><br><span class="line">    get: function () &#123;</span><br><span class="line">        this.value = this.sommer.data[this.name];   //触发数据的get方法</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">//observe.js</span><br><span class="line"></span><br><span class="line">//监控Sommer中data的变化</span><br><span class="line">function observe (data) &#123;</span><br><span class="line">    Object.keys(data).forEach(function(key) &#123;</span><br><span class="line">        definePro(data, key, data[key]);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line">function definePro (data, key, val) &#123;</span><br><span class="line">    var dep = new Dep();</span><br><span class="line">    Object.defineProperty(data, key, &#123;</span><br><span class="line">        enumerable: true,</span><br><span class="line">        configurable: true,</span><br><span class="line">        get: function() &#123;</span><br><span class="line">            //添加订阅者watcher到订阅者集合中，JS的浏览器单线程特性，保证这个全局变量在同一个时间内只会有一个watcher使用</span><br><span class="line">            if (Dep.target) &#123;</span><br><span class="line">                dep.addSub(Dep.target);</span><br><span class="line">            &#125;</span><br><span class="line">            return val;</span><br><span class="line">        &#125;,</span><br><span class="line">        set: function(newVal) &#123;</span><br><span class="line">            val = newVal;</span><br><span class="line">            console.log(&apos;属性&apos; + key + &apos;已经被监听了，现在值为：&apos; + newVal);</span><br><span class="line">            //触发set函数后，发布者发出通知</span><br><span class="line">            dep.notify();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//compile.js</span><br><span class="line"></span><br><span class="line">function Compile (node, sommer) &#123;</span><br><span class="line">    return this.node2Fragment(node, sommer);</span><br><span class="line">&#125;</span><br><span class="line">Compile.prototype = &#123;</span><br><span class="line">    //编译dom流程：</span><br><span class="line">    // 1.将挂载目标的所有子节点劫持到DocumentFragment</span><br><span class="line">    // 2.然后针对不同的节点类型进行解析数据绑定的处理</span><br><span class="line"></span><br><span class="line">    node2Fragment: function (node, sommer) &#123;</span><br><span class="line">        var _this = this,</span><br><span class="line">            child,</span><br><span class="line">            frag = document.createDocumentFragment();</span><br><span class="line">        while(child = node.firstChild) &#123;</span><br><span class="line">            _this.handleBind(child, sommer);</span><br><span class="line">            frag.append(child);    //append进文档片段之后，dom中的该节点会自动删除，所以child永远都是第一个子节点，直到子节点劫持完成为止</span><br><span class="line">        &#125;</span><br><span class="line">        return frag;</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    handleBind: function (node, sommer) &#123;</span><br><span class="line">        var reg = /\&#123;\&#123;(.*)\&#125;\&#125;/;   //文本插入分隔符正则匹配，vue可以通过delimiters:[&apos;$&#123;&apos;, &apos;&#125;&apos;]进行配置</span><br><span class="line"></span><br><span class="line">        //根据节点类型进行分别处理，1----元素节点，3----文本节点</span><br><span class="line">        if (node.nodeType === 1) &#123;</span><br><span class="line">            var attr = node.attributes,</span><br><span class="line">                attrLen = attr.length;</span><br><span class="line">            for (var i = 0; i &lt; attrLen; i++) &#123;</span><br><span class="line">                //解析s-model属性</span><br><span class="line">                if (attr[i].nodeName == &quot;s-model&quot;) &#123;</span><br><span class="line">                    var modelName = attr[i].nodeValue;  //获取s-model绑定的属性名</span><br><span class="line">                    node.addEventListener(&quot;input&quot;, function (e) &#123;</span><br><span class="line">                        //更改data中的相应属性，触发这个属性的set方法</span><br><span class="line">                        sommer.data[modelName] = e.target.value;</span><br><span class="line">                    &#125;);</span><br><span class="line">                    //node.value = sommer.data[modelName];    //将数据赋值给节点</span><br><span class="line">                    node.removeAttribute(&quot;s-model&quot;);    //移除节点上的s-model属性</span><br><span class="line">                    new Watcher(sommer, node, modelName, &quot;value&quot;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if (node.nodeType === 3) &#123;</span><br><span class="line">            if (reg.test(node.nodeValue)) &#123;</span><br><span class="line">                var name = RegExp.$1.trim();  //匹配到的分隔符里的字符串</span><br><span class="line">                //node.nodeValue = sommer.data[name];    //将数据模型中的该属性值赋值给这个节点</span><br><span class="line">                new Watcher(sommer, node, name, &quot;nodeValue&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>再说一遍发布订阅模式吧。。。</p><p>Sommer对象里的data就是我们要监听的对象，data的所有属性都拥有一个调度中心Dep，每一个挂载了data中的某个属性的节点就称为一个订阅者（watcher）。每当data中的某个属性发生了改变，那么这个属性的set函数就会被触发，在set函数里用Dep去发布通知说，诶，我这个属性xxx动了哦，你们各就各位哦，然后订阅者就闻风而动了。</p><p>在watch模块里面定义了一个订阅者管理器，一个订阅者的调度中心Dep。因为订阅者会有很多个，所以需要进行统一的管理操作，它提供了添加订阅者和发布通知的方法。</p><p>在compile模块里，我们给每个带绑定属性的节点生成了一个订阅者watcher，订阅者会将自己添加到相应属性的Dep中。而这个watcher都干了些啥嘞，看代码↑</p><p>首先，它将自己赋值给了一个全局变量Dep.target，然后执行了update方法，这个update方法里面执行了get方法，get方法去读取了这个属性，从而触发了这个属性的get方法，回到compile里面，这个属性的get方法将watcher添加到了订阅者管理器（Dep）中，接着，在update方法里获取到了属性的值，更新了这个节点的值，更新视图，最后置空。</p><p>初始化订阅者完成后，当修改了数据，触发了这个属性的set方法，发布了通知dep.notify()，就去触发了这个调度中心里各个订阅者的update方法，执行上面那段操作，去更新视图，至此，双向绑定就基本实现了。效果图，唔，上面都有。</p><p>这个只是简单的一个实现，说一下究其根本的原理，实际实现vue真的十分复杂，源代码看得我头皮发麻= =</p><p>这篇文章，真的是再续前缘~虽然大多数都是最近才写的⁄(⁄ ⁄•⁄ω⁄•⁄ ⁄)⁄还是学到了很多~</p><p>最后，上面那些爱看不看的，还是要看的。</p><p>参考：</p><ul><li><a href="https://www.kancloud.cn/zmwtp/vue2/148822" target="_blank" rel="noopener">vue2.0源代码解析</a></li><li><a href="https://segmentfault.com/a/1190000006599500" target="_blank" rel="noopener">剖析双向绑定</a></li><li><a href="https://juejin.im/entry/5996654451882524382f43db" target="_blank" rel="noopener">流程图解双向绑定。。。我觉得是真的很有用</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;相关&quot;&gt;&lt;a href=&quot;#相关&quot; class=&quot;headerlink&quot; title=&quot;相关&quot;&gt;&lt;/a&gt;相关&lt;/h3&gt;&lt;p&gt;随便联想的衍生知识点~ 大概&lt;del&gt;不会&lt;/del&gt;有机会填坑&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://www.cnbl
      
    
    </summary>
    
    
      <category term="mvvm" scheme="http://yoursite.com/tags/mvvm/"/>
    
      <category term="双向绑定" scheme="http://yoursite.com/tags/%E5%8F%8C%E5%90%91%E7%BB%91%E5%AE%9A/"/>
    
  </entry>
  
  <entry>
    <title>辨析 Sass 中的 Map 和 List</title>
    <link href="http://yoursite.com/2015/10/21/demo/"/>
    <id>http://yoursite.com/2015/10/21/demo/</id>
    <published>2015-10-21T02:34:12.000Z</published>
    <updated>2018-07-25T18:46:27.257Z</updated>
    
    <content type="html"><![CDATA[<p>如果你使用过 Sass 3.3 之前的版本，那么你一定对那段时光颇有感触，那时候没有现如今这么好的条件，那时候的 Map 还只能用多重列表（lists of list）来模拟。多重列表可以实现复杂数据的嵌套定义，但却不是以键值对的形式实现的，所有当我们需要获取其中特定的某一项时就会比较麻烦。Map 这种数据类型天生就是基于键值对的形式，非常便于组织数据。</p><p>自从可以使用 Map 之后，开发者们开始毫无顾忌地定义 Map 存储数据，比如断点宽度、颜色值、栅格布局等等响应式排版的细节，都被一股脑的塞进了 Map 中。</p><p>那么，有了 Map 之后，我们还有必要使用 List 吗？可能某些人会觉得为了保持向后兼容应该继续使用多重列表模拟 Map，因为可能有些开发者仍然在使用老版本的 Sass 编译器，但实际上，这是多此一举了，Sass 的版本通常由 <code>package.json</code> 或者其他同类型的项目配置文件所控制，往往只需一条命令（<code>gem update sass</code>）即可更新 Sass 的版本，因此基本上无需考虑对老版本的兼容问题。</p><a id="more"></a><p>使用多重列表替代 Map 的优势之一就是减少代码量。下面让我们来比较一下多种列表和 Map 的语法结构以及遍历方式。</p><h2 id="测试表格"><a href="#测试表格" class="headerlink" title="测试表格"></a>测试表格</h2><table><thead><tr><th>Variable</th><th>Description</th></tr></thead><tbody><tr><td><code>site</code></td><td>Sitewide information.</td></tr><tr><td><code>page</code></td><td>Page specific information and custom variables set in front-matter.</td></tr><tr><td><code>config</code></td><td>Site configuration</td></tr><tr><td><code>theme</code></td><td>Theme configuration. Inherits from site configuration.</td></tr><tr><td><code>_</code> (single underscore)</td><td><a href="http://lodash.com/" target="_blank" rel="noopener">Lodash</a> library</td></tr><tr><td><code>path</code></td><td>Path of current page</td></tr><tr><td><code>url</code></td><td>Full URL of current page</td></tr><tr><td><code>env</code></td><td>Environment variables</td></tr></tbody></table><h2 id="语法比较"><a href="#语法比较" class="headerlink" title="语法比较"></a>语法比较</h2><div class="note"><br>    <h5>测试标题</h5><br>    <p>在下面的示例中，我创建了一个用于控制响应式布局的数据，该数据一共有四个断点，每一个断点都包含了 <code>min-width</code>、<code>max-width</code>、<code>font-size</code> 和 <code>line-height</code> 四个样式。</p><br></div><h4 id="Map-语法"><a href="#Map-语法" class="headerlink" title="Map 语法"></a>Map 语法</h4><p>下面就是使用 Map 存储的数据，具体来说，该 Map 中首先存储了四个用于标识断点的 Key，相对应的是保存具体属性值得 Value。虽然这种形式可读性更高，但是总体代码量却高达 26 行 450 个字符。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">$breakpoint-map: (</span><br><span class="line">    small: (</span><br><span class="line">        min-width: null,</span><br><span class="line">        max-width: 479px,</span><br><span class="line">        base-font: 16px,</span><br><span class="line">        vertical-rhythm: 1.3</span><br><span class="line">    ),</span><br><span class="line">    medium: (</span><br><span class="line">        min-width: 480px,</span><br><span class="line">        max-width: 959px,</span><br><span class="line">        base-font: 18px,</span><br><span class="line">        vertical-rhythm: 1.414</span><br><span class="line">    ),</span><br><span class="line">    large: (</span><br><span class="line">        min-width: 960px,</span><br><span class="line">        max-width: 1099px,</span><br><span class="line">        base-font: 18px,</span><br><span class="line">        vertical-rhythm: 1.5</span><br><span class="line">    ),</span><br><span class="line">    xlarge: (</span><br><span class="line">        min-width: 1100px,</span><br><span class="line">        max-width: null,</span><br><span class="line">        base-font: 21px,</span><br><span class="line">        vertical-rhythm: 1.618</span><br><span class="line">    )</span><br><span class="line">);</span><br></pre></td></tr></table></figure><h4 id="多重列表语法"><a href="#多重列表语法" class="headerlink" title="多重列表语法"></a>多重列表语法</h4><p>下面的多重列表存储了和上面 Map 同样的数据，在多重列表中没有 Key-Value 的对应关系，这意味着要想找到特定的值，必须使用遍历或 <code>nth()</code> 的方式来实现了。从另一个角度来看，多种列表又比 Map 的代码量小得多，总共只有六行 180 个字符。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$breakpoint-list: (</span><br><span class="line">    (small, null, 479px, 16px, 1.3),</span><br><span class="line">    (medium, 480px, 959px, 18px, 1.414),</span><br><span class="line">    (large, 960px, 1099px, 18px, 1.5),</span><br><span class="line">    (xlarge, 1100px, null, 21px, 1.618)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><h2 id="遍历比较"><a href="#遍历比较" class="headerlink" title="遍历比较"></a>遍历比较</h2><div class="note info"><br>    <h5>测试标题</h5><br>    <p>从上面简单地比较中可以粗略的看出，多种列表的代码量明显少于 Map。但是，如果我们需要遍历这些值得话，复杂度又是怎样的呢？</p><br></div><h4 id="遍历-Map"><a href="#遍历-Map" class="headerlink" title="遍历 Map"></a>遍历 Map</h4><p>我们可以使用如下的代码遍历 Map：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@each $label, $map in $breakpoint-map &#123;&#125;</span><br></pre></td></tr></table></figure><p>这里的变量 <code>$label</code> 和 <code>$map</code> 会随着对 <code>$breakpoint-map</code> 的遍历被动态地赋值，<code>$label</code> 将会被赋值为 <code>$breakpoint-map</code> 的 Key，而 <code>$map</code> 会被赋值为 <code>$breakpoint-map</code> 的 Value。为了在遍历过程中获取特定值，我们就需要使用 Sass 原生的 <code>map-get()</code> 函数，使用该函数需要传入两个参数：Map 的名字和求取的 Key，最后返回该 Map 中匹配该 Key 的 Value。</p><p>具体的做法就是使用 <code>@each</code> 遍历 Map，然后使用 <code>map-get()</code> 获取特定值，最终只需要六行代码 220 个字符即可完成整个遍历：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@each $label, $map in $breakpoint-map &#123;</span><br><span class="line">    $min-width: map-get($map, min-width);</span><br><span class="line">    $max-width: map-get($map, max-width);</span><br><span class="line">    $base-font: map-get($map, base-font);</span><br><span class="line">    $vertical-rhythm: map-get($map, vertical-rhythm);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="遍历多重列表"><a href="#遍历多重列表" class="headerlink" title="遍历多重列表"></a>遍历多重列表</h4><p>遍历多重列表不必像遍历 Map 一样动态获取到 Map 后再使用 <code>map-get()</code> 函数取特定值，直接遍历一遍即可获得特定值。</p><p>因为多种列表内层的每一个列表结构相同，都有按照相同顺序排列的五个值，所以我们可以持续遍历每个值并赋值给特定的变量。无需调用 <code>map-get()</code>，直接引用这些变量即可进行赋值等裸机操作。最终遍历多重列表只使用了两行代码 100 个字符：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@each $label, $min-width, $max-width, $base-font, $vertical-rhythm in $breakpoint-list &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="慎用多重列表"><a href="#慎用多重列表" class="headerlink" title="慎用多重列表"></a>慎用多重列表</h2><div class="note warning"><br>    <h5>测试标题</h5><br>    <p>经过上述的比对，看起来多重列表各方面都在碾压 Map，实则不然，Sass 中添加 Map 有一条非常重要的原因就是：Key-Value 的映射关系。</p><br></div><h4 id="遗漏键值"><a href="#遗漏键值" class="headerlink" title="遗漏键值"></a>遗漏键值</h4><p>如果要使用多重列表，那么就必须保证自己非常熟悉多重列表内部的每一项所代表的意义。下面我们举个例子，来看看遗漏了某些值的情况：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">$breakpoint-list: (</span><br><span class="line">    (small, null, 479px, 16px, 1.3),</span><br><span class="line">    (medium, 480px, 959px, 18px, 1.414),</span><br><span class="line">    (large, 960px, 1099px, 18px, 1.5),</span><br><span class="line">    (xlarge, 1100px, 21px, 1.618)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">p &#123;</span><br><span class="line">    @each $label, $min-width, $max-width, $base-font, $vertical-rhythm in $breakpoint-list &#123;</span><br><span class="line">        @if $min-width &#123;</span><br><span class="line">            @include breakpoint( $min-width ) &#123;</span><br><span class="line">                font-size: $base-font;</span><br><span class="line">                line-height: $vertical-rhythm;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; @else &#123;</span><br><span class="line">            font-size: $base-font;</span><br><span class="line">            line-height: $vertical-rhythm;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当我们尝试运行这段代码时，结果肯定是错误地，因为在 <code>$breakpoint-list</code> 的最后一行，<code>xlarge</code> 被赋值给了 <code>$label</code>，<code>1100px</code> 被赋值给了 <code>$min-width</code>，<code>21px</code> 被赋值给了 <code>$max-width</code>, <code>1.618</code> 被赋值给了 <code>$base-font</code>，最终导致 <code>$vertical-rhythm</code> 没有被赋值，结果就是 <code>font-size</code> 的属性值是错的，<code>line-height</code> 的属性值是空的。此外，Sass 还不会对此抛出错误，导致我们无从知晓错误所在。</p><p>如果我们使用 Map 来代替这里的多重列表，那么使用 <code>map-get()</code> 函数即使遇见空值也能正确获得想要的结果。这就是值得我们慎重思考的地方：多种列表虽然简单快速，但是丧失了 Map 中的容错能力和快速取值能力。</p><h4 id="查找特定列表"><a href="#查找特定列表" class="headerlink" title="查找特定列表"></a>查找特定列表</h4><p>在多重列表中查找特定列表简直就是一种折磨。如果使用 Map，那么配合 <code>map-get()</code> 函数可以快速定位到特定子 Map：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$medium-map: map-get($maps, medium);</span><br></pre></td></tr></table></figure><p>但如果要获取多种列表 <code>medium</code> 列表，麻烦可就大了：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@function get-list($label) &#123;</span><br><span class="line">    @each $list in $breakpoint-list &#123;</span><br><span class="line">        @if nth($list, 1) == $label &#123;</span><br><span class="line">            @return $list;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    @return null;</span><br><span class="line">&#125;</span><br><span class="line">$medium-list: get-list(medium);</span><br></pre></td></tr></table></figure><p>这段代码的逻辑就是遍历整个多重列表，知道找到第一个匹配项，然后返回，如果一直没有找到匹配项，就一直遍历到末尾，然后返回 <code>null</code>。这实际上就是手工实现了 <code>map-get()</code> 的逻辑。</p><h4 id="缺少原生的-Map-函数"><a href="#缺少原生的-Map-函数" class="headerlink" title="缺少原生的 Map 函数"></a>缺少原生的 Map 函数</h4><p>Sass 提供了诸多的原生函数用于处理 Map 数据类型，但是多重列表是没法调用这些函数的，比如，使用 <code>map-merge()</code> 可以合并两个 Map，如果两个 Map 有相同的值，则取第二个 Map 的值为最终值。当然你也可以在多重列表中使用 <code>join()</code> 或 <code>append()</code> 来增加新列表，从而模拟出 <code>map-merge()</code> 的效果。</p><p>另一个实用的 Map 函数就是 <code>map-has-key()</code>，对于依赖 <code>map-get()</code> 的自定义函数来说，<code>map-has-key()</code> 可以用来验证特定的 Key 是否存在。但在列表中是完全没有相似的方法。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><div class="note unreleased"><br>    <h5>Test Title</h5><br>    <p>相比起列表来说，Key-Value 模型的 Map 显然更有力量，原生的 Sass Map 函数更是提供了强力的数据查找和验证工具。</p><br></div><p>虽然多重列表代码量少，但并不能像 Map 一样进行错误检查或验证参数。在大多数时候，相比较多重列表而言，我相信 Map 是更好的选择。如果是为了更少的代码量和其他简单地调用，那么我偶尔会用用多重列表，但是从项目的宏观控制和数据存储方面显然更优秀。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;如果你使用过 Sass 3.3 之前的版本，那么你一定对那段时光颇有感触，那时候没有现如今这么好的条件，那时候的 Map 还只能用多重列表（lists of list）来模拟。多重列表可以实现复杂数据的嵌套定义，但却不是以键值对的形式实现的，所有当我们需要获取其中特定的某一项时就会比较麻烦。Map 这种数据类型天生就是基于键值对的形式，非常便于组织数据。&lt;/p&gt;
&lt;p&gt;自从可以使用 Map 之后，开发者们开始毫无顾忌地定义 Map 存储数据，比如断点宽度、颜色值、栅格布局等等响应式排版的细节，都被一股脑的塞进了 Map 中。&lt;/p&gt;
&lt;p&gt;那么，有了 Map 之后，我们还有必要使用 List 吗？可能某些人会觉得为了保持向后兼容应该继续使用多重列表模拟 Map，因为可能有些开发者仍然在使用老版本的 Sass 编译器，但实际上，这是多此一举了，Sass 的版本通常由 &lt;code&gt;package.json&lt;/code&gt; 或者其他同类型的项目配置文件所控制，往往只需一条命令（&lt;code&gt;gem update sass&lt;/code&gt;）即可更新 Sass 的版本，因此基本上无需考虑对老版本的兼容问题。&lt;/p&gt;
    
    </summary>
    
    
      <category term="css" scheme="http://yoursite.com/tags/css/"/>
    
  </entry>
  
</feed>
