---
title: MVVM的双向绑定
date: 2018-05-31 00:19:55
tags:
- mvvm
- 双向绑定
---

### 相关
随便联想的衍生知识点~ 大概~~不会~~有机会填坑
+ [m三连：MVC、MVP和MVVM](http://www.cnblogs.com/indream/p/3602348.html)
+ [vdom](https://www.kancloud.cn/zmwtp/vue2/149727)
+ [documentFragment](https://blog.csdn.net/u010582082/article/details/70196854)

## 引言
说到双向绑定，就会想到MVVM模式。之前实习依次经历过MVC、MVP和MVVM模式，在MVC和MVP模式里，数据还只是单向绑定，即把Model绑定到View，当我们用js更新Model时，View就会自动更新，反之，不然。

而MVVM模式就很不一样啦，它的viewModel大体上就是MVC里的Controller和MVP里的Presenter了。只是MVVM模式里面View和ViewModel之间没有了MVP里的界面接口，变成了直接交互，数据和视图是双向绑定的关系，双向绑定不仅拥有单向绑定的效果，还拥有单向绑定的反之效果，即如果用户更新了View，Model的数据也自动被更新了。<font size=1>（总算成功引入了双向绑定了= =）</font>

那么什么时候才会更新view嘞？最常见的操作就是表单输入啦~ 用户输入数据，更新了视图层，此时MVVM框架自动更新Model，那么这个数据就跟着视图的变化而变化了。

### 举个栗子
vue.js就是一个使用了MVVM模式的js库。这里来一段粗糙简陋的代码示范一下
```
    <div id="vm">
        <input type="text" v-model="obj.msg">
        <p>{{ obj.msg }}</p>
    </div>
    <script>
        new Vue({
            el: "#vm",
            data: {
                obj: {
                    msg: "嘿嘿嘿"
                }
            },
            created: function () {
                console.log(this.obj);
            }
        });
    </script>
```

效果：

![vue demo](https://sirllight.github.io/img/vue-demo.gif)

双向数据绑定大概就是这个样子，就是视图（View）的变化能实时让数据模型（Model）发生变化，而数据的变化也能实时更新到视图层。分解一下这里面的操作就是双向数据绑定的基本实现流程啦~

+ 监听视图的变化
+ 将视图的变化更新到数据模型
+ 监听数据模型的变化
+ 将数据模型的变化更新到视图

视图层的变化主要交互造成的，比如用户输入、点击等等。那么我们只需要监听这些交互的事件，然后在事件回调函数中，将变化的值更新到Model中，这就实现了视图层变化更新数据模型。

数据模型变化的监听方式主要有三种：发布订阅模式（Backbone.js），脏数据检查（Angular.js），数据劫持（Vue.js）。

#### 发布订阅模式
发布订阅模式也叫作观察者模式，我的理解就是，唔，举个栗子，原生js中的事件监听就是这么一种模式。触发一个事件，就是发布了一个通知，这个通知的订阅者（addEventListener）去订阅这个回调函数，就可以执行相应的操作。落到数据绑定上就是，当数据发生了变动，就发布通知，订阅者收到这个发布，就去执行相应的操作。唔，大概就这样，具体的这里不讲，扔个链接，[爱看不看](http://www.html-js.com/article/Study-of-twoway-data-binding-JavaScript-talk-about-JavaScript-every-day)，这里还有个js观察者模式的文章，[依然是爱看不看](http://www.cnblogs.com/TomXu/archive/2012/03/02/2355128.html)

#### 脏数据检查
顾名思义，就是通过脏值检测的方式比对数据是否有变更，来决定是否更新视图，最简单的方式就是通过 setInterval() 定时轮询检测数据变动，当然Google不会这么low，angular只有在指定的事件触发时进入脏值检测，大致如下：

+ DOM事件，譬如用户输入文本，点击按钮等。( ng-click )
+ XHR响应事件 ( $http )
+ 浏览器Location变更事件 ( $location )
+ Timer事件( $timeout , $interval )
+ 执行 $digest() 或 $apply()

嗷，这一段是我复制粘贴的，对angular了解不深，一直~~懒得~~没有~~兴趣~~时间去了解，以后再说吧，留一个链接，[照旧爱看不看](https://github.com/xufei/blog/issues/10)

#### 数据劫持
这一个方法就是这篇文章的重点了，入门vue.js的时候有些情怀，我更愿意接触它。嗷，现在对react也有感情了，女人，就是这么感性(#^.^#)，嘻嘻。唔，说回数据劫持。

ES5中对象的属性有了属性描述符，Object.defineProperty就是ES5新加的给对象属性设置描述符的方法。这个方法是真的了不起，它用下面的方式（数据描述符和存取描述符）去设置对象属性：
```
    Object.defineProperty(obj, key,{
        value: "",
        writable: true,
        enumerable: true,
        configurable: true
    })
```
除此之外，它还有get，set的存取描述符给属性提供getter和setter方法。当存在getter，setter函数时，属性的赋值操作会触发setter函数的执行，获取操作会触发getter函数的执行。用术语来讲，这样的方法叫数据劫持<font size=1>（显得十分牛逼高深的样子）</font>。举个栗子：
```
    var info = {};
    Object.defineProperty(info, "name", {
        set: function (value) {
            name = value;
            console.log("set name :" + value);
        },
        get: function () {
            return "get name :" + name;
        }
    });
    info.name = "啦啦啦";
    console.log(info.name);
```
效果你们自己复制一下代码，跑个js脚本自己看咯。。。唔，算了，还是截个图:

![Object.defineProperty demo](https://sirllight.github.io/img/definePro-demo.png)

关于这个方法具体情况，唔，[这是一条链接，爱看不看](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty)。之所以说这个方法很了不起，就是因为vue.js双向绑定最核心的方法就是它，可以打印一下vue中初始化数据的对象和我们自己用Object.defineProperty()定义的对象：
```
    <div id="vm">
        <input type="text" v-model="obj.msg">
        <p>{{ obj.msg }}</p>
    </div>

    <script>
        new Vue({
            el: "#vm",
            data: {
                obj: {
                    msg: "嘿嘿嘿"
                }
            },
            created: function () {
                console.log(this.obj);
            }
        });

        console.log("====");

        var info = {};
        Object.defineProperty(info, "name", {
            set: function (value) {
                name = value;
                console.log("set name :" + value);
            },
            get: function () {
                return "get name :" + name;
            }
        });
        info.name = "啦啦啦";
        console.log(info.name);
        console.log(info);
    </script>
```
效果：

![data demo](https://sirllight.github.io/img/data-demo.png)

乍一眼，看起来就很像了，是吧。vue.js就是采用数据劫持结合发布订阅模式的方式，通过Object.defineProperty()来劫持各个属性的setter，getter，在数据变动时发布消息给订阅者，触发相应的监听回调来实现双向数据绑定的。

### vue.js实现双向绑定基本思路

实现MVVM主要包含两个方面：数据变化更新视图，视图变化更新数据。因为view更新model可以通过事件监听去实现，比如说监听输入事件，所以关键就在于如果数据变化怎么去更新视图。这个时候就用上了上面说的数据劫持，通过Object.defineProperty()对属性设置一个setter函数，当数据改变了就会来触发这个函数，就可以在这个函数里去更新model。
vue.js在这个地方使用了发布订阅的模式去进行更新model的操作。因为订阅者（watcher）会有很多个，所以就有一个消息订阅器Dep来专门收集管理这些订阅者，通过“订阅”数据变动，去执行相应的更新view的操作。双向绑定基本思路就这样，现在可以来简要实现一下。

### 简要实现
首先，用数据劫持简单实现一下我们想要的表现效果：
```
    <div id="vm">
        <input type="text" id="input">
        <p id="value"></p>
    </div>

    <script>
        var data = {};
        Object.defineProperty(data, "msg", {
            set: function (value) {
                msg = value;
                console.log("set input data :" + value);
                document.getElementById("value").innerHTML = value;
            },
            get: function () {
                return msg;
            }
        });
        document.getElementById("input").addEventListener("keyup", function (e) {
            data.msg = e.target.value;
        });
    </script>
```
效果如图：

![define-pro-demo](https://sirllight.github.io/img/define-pro-demo.gif)

虽然这是我们想要得到的效果，但是通过document.getElementById获取到相应的节点对象，然后去改变节点的值，这种做法是真的很粗暴了，一点都不优雅。如果封装成一个框架，这种做法肯定是不可行的，所以我们需要一个提高性能和效率的模块去解析dom并修改dom中相应变量。

#### 简单实现一个编译器Compile 

对着代码说话 
```
    <div id="vm">
        <input type="text" s-model="input">
        {{ input }}
    </div>
    <script>
        function Sommer (options) {
            this.data = options.data;
            var id = options.el;
            var dom = new Compile(document.getElementById(id), this);
            document.getElementById(id).appendChild(dom);
        }
        new Sommer({
            el: "vm",
            data: {
                input: "嘿嘿嘿"
            }
        })
    </script>
    
    //compile.js

    function Compile (node, sommer) {
        return this.node2Fragment(node, sommer);
    }

    Compile.prototype = {
        //编译dom流程：
        // 1.将挂载目标的所有子节点劫持到DocumentFragment
        // 2.然后针对不同的节点类型进行解析数据绑定的处理

        node2Fragment: function (node, sommer) {
            var _this = this,
                child,
                frag = document.createDocumentFragment();

            while(child = node.firstChild) {
                _this.handleBind(child, sommer);
                frag.append(child);    //append进文档片段之后，dom中的该节点会自动删除，所以child永远都是第一个子节点，直到子节点劫持完成为止
            }
            return frag;
        },

        handleBind: function (node, sommer) {
            var reg = /\{\{(.*)\}\}/;   //文本插入分隔符正则匹配，vue可以通过delimiters:['${', '}']进行配置

            //根据节点类型进行分别处理，1----元素节点，3----文本节点
            if (node.nodeType === 1) {
                var attr = node.attributes,
                    attrLen = attr.length;
                for (var i = 0; i < attrLen; i++) {
                    //解析s-model属性
                    if (attr[i].nodeName == "s-model") {
                        var modelName = attr[i].nodeValue;  //获取s-model绑定的属性名
                        node.addEventListener("input", function (e) {
                            //更改data中的相应属性，触发这个属性的set方法
                            sommer.data[modelName] = e.target.value;
                        });
                        node.value = sommer.data[modelName];    //将数据赋值给节点
                        node.removeAttribute("s-model");    //移除节点上的s-model属性
                    }
                }
            }
            if (node.nodeType === 3) {
                if (reg.test(node.nodeValue)) {
                    var name = RegExp.$1.trim();  //匹配到的分隔符里的字符串
                    node.nodeValue = sommer.data[name];    //将数据模型中的该属性值赋值给这个节点
                }
            }
        }
    };
```

这个地方用到了文档碎片DocumentFragment，以前看过，觉得好像没地方用，没想到用处还是挺大的，很复杂的心情。。。这段代码的作用就是将挂在的目标节点下的所有子节点转换成文档碎片进行编译操作，等编译完成之后再将碎片添加到真实的dom节点中，在性能和效率上确实有明显的提高。

虽然代码注释还是很详细的，但是我在这里还是叨叨一下吧，首先，获取到真实的dom节点，然后分析节点的类型，根据不同的类型去解析绑定数据的标志，获取到绑定的变量，然后进行一些操作处理。这个地方就不截图了，效果就是实现了用s-model和双花括号绑定数据。

#### 实现简单的observe
实现了数据绑定节点之后，就可以用数据劫持对数据进行监听了，不多说，先看代码<font size=1>（html代码没变就不拿上来了）</font>：
```
    function Sommer (options) {
        this.data = options.data;
        observe(this.data);
        var id = options.el;
        var dom = new Compile(document.getElementById(id), this);
        document.getElementById(id).appendChild(dom);
    }
    
    //observe.js
    
    //监控Sommer中data的变化
    function observe (data) {
        Object.keys(data).forEach(function(key) {
            definePro(data, key, data[key]);
        });
    }

    function definePro (data, key, val) {
        Object.defineProperty(data, key, {
            enumerable: true,
            configurable: true,
            get: function() {
                return val;
            },
            set: function(newVal) {
                val = newVal;
                console.log('属性' + key + '已经被监听了，现在值为：' + newVal);
            }
        });
    }
```

这里使用数据劫持对Sommer中的data进行监听，当get和set方法触发后进行相应的操作，效果如图：

![observe-demo](https://sirllight.github.io/img/observe-demo.gif)

可以看到虽然set方法触发了，但是文本节点的内容没有变化，我们接下来就要实现让绑定的文本节点同步变化，这个时候，就需要使用到发布订阅模式。

#### 发布订阅模式

[还是先上代码](https://github.com/SirlLight/mvvm)
```
    //watch.js
    
    function Dep () {
        this.subs = [];
    }
    Dep.prototype = {
        addSub: function(sub) {
            this.subs.push(sub);
        },
        notify: function() {
            this.subs.forEach(function(sub) {
                sub.update();
            })
        }
    };
    function Watcher (sommer, node, name, type) {
        Dep.target = this;  //将自己赋值给了全局变量dep.target
        this.name = name;
        this.node = node;
        this.sommer = sommer;
        this.type = type;
        this.update();
        Dep.target = null;  //因为它是全局变量，也是 watcher 与 dep 关联的唯一桥梁，任何时刻都必须保证 Dep.target 只有一个值。
    }
    Watcher.prototype = {
        update: function () {
            this.get();
            this.node[this.type] = this.value;
        },
        get: function () {
            this.value = this.sommer.data[this.name];   //触发数据的get方法
        }
    };
    
    //observe.js
    
    //监控Sommer中data的变化
    function observe (data) {
        Object.keys(data).forEach(function(key) {
            definePro(data, key, data[key]);
        });
    }
    function definePro (data, key, val) {
        var dep = new Dep();
        Object.defineProperty(data, key, {
            enumerable: true,
            configurable: true,
            get: function() {
                //添加订阅者watcher到订阅者集合中，JS的浏览器单线程特性，保证这个全局变量在同一个时间内只会有一个watcher使用
                if (Dep.target) {
                    dep.addSub(Dep.target);
                }
                return val;
            },
            set: function(newVal) {
                val = newVal;
                console.log('属性' + key + '已经被监听了，现在值为：' + newVal);
                //触发set函数后，发布者发出通知
                dep.notify();
            }
        });
    }
    
    //compile.js
    
    function Compile (node, sommer) {
        return this.node2Fragment(node, sommer);
    }
    Compile.prototype = {
        //编译dom流程：
        // 1.将挂载目标的所有子节点劫持到DocumentFragment
        // 2.然后针对不同的节点类型进行解析数据绑定的处理

        node2Fragment: function (node, sommer) {
            var _this = this,
                child,
                frag = document.createDocumentFragment();
            while(child = node.firstChild) {
                _this.handleBind(child, sommer);
                frag.append(child);    //append进文档片段之后，dom中的该节点会自动删除，所以child永远都是第一个子节点，直到子节点劫持完成为止
            }
            return frag;
        },

        handleBind: function (node, sommer) {
            var reg = /\{\{(.*)\}\}/;   //文本插入分隔符正则匹配，vue可以通过delimiters:['${', '}']进行配置

            //根据节点类型进行分别处理，1----元素节点，3----文本节点
            if (node.nodeType === 1) {
                var attr = node.attributes,
                    attrLen = attr.length;
                for (var i = 0; i < attrLen; i++) {
                    //解析s-model属性
                    if (attr[i].nodeName == "s-model") {
                        var modelName = attr[i].nodeValue;  //获取s-model绑定的属性名
                        node.addEventListener("input", function (e) {
                            //更改data中的相应属性，触发这个属性的set方法
                            sommer.data[modelName] = e.target.value;
                        });
                        //node.value = sommer.data[modelName];    //将数据赋值给节点
                        node.removeAttribute("s-model");    //移除节点上的s-model属性
                        new Watcher(sommer, node, modelName, "value");
                    }
                }
            }
            if (node.nodeType === 3) {
                if (reg.test(node.nodeValue)) {
                    var name = RegExp.$1.trim();  //匹配到的分隔符里的字符串
                    //node.nodeValue = sommer.data[name];    //将数据模型中的该属性值赋值给这个节点
                    new Watcher(sommer, node, name, "nodeValue");
                }
            }
        }
    };
```

再说一遍发布订阅模式吧。。。

Sommer对象里的data就是我们要监听的对象，data的所有属性都拥有一个调度中心Dep，每一个挂载了data中的某个属性的节点就称为一个订阅者（watcher）。每当data中的某个属性发生了改变，那么这个属性的set函数就会被触发，在set函数里用Dep去发布通知说，诶，我这个属性xxx动了哦，你们各就各位哦，然后订阅者就闻风而动了。

在watch模块里面定义了一个订阅者管理器，一个订阅者的调度中心Dep。因为订阅者会有很多个，所以需要进行统一的管理操作，它提供了添加订阅者和发布通知的方法。

在compile模块里，我们给每个带绑定属性的节点生成了一个订阅者watcher，订阅者会将自己添加到相应属性的Dep中。而这个watcher都干了些啥嘞，看代码↑

首先，它将自己赋值给了一个全局变量Dep.target，然后执行了update方法，这个update方法里面执行了get方法，get方法去读取了这个属性，从而触发了这个属性的get方法，回到compile里面，这个属性的get方法将watcher添加到了订阅者管理器（Dep）中，接着，在update方法里获取到了属性的值，更新了这个节点的值，更新视图，最后置空。

初始化订阅者完成后，当修改了数据，触发了这个属性的set方法，发布了通知dep.notify()，就去触发了这个调度中心里各个订阅者的update方法，执行上面那段操作，去更新视图，至此，双向绑定就基本实现了。效果图，唔，上面都有。

这个只是简单的一个实现，说一下究其根本的原理，实际实现vue真的十分复杂，源代码看得我头皮发麻= =

这篇文章，真的是再续前缘~虽然大多数都是最近才写的⁄(⁄ ⁄•⁄ω⁄•⁄ ⁄)⁄还是学到了很多~

最后，上面那些爱看不看的，还是要看的。

参考：
* [vue2.0源代码解析](https://www.kancloud.cn/zmwtp/vue2/148822)
* [剖析双向绑定](https://segmentfault.com/a/1190000006599500)
* [流程图解双向绑定。。。我觉得是真的很有用](https://juejin.im/entry/5996654451882524382f43db)